"use strict";
/** [[include:doc/result.md]] */
Object.defineProperty(exports, "__esModule", { value: true });
/** (keep typedoc from getting confused by the import) */
const maybe_1 = require("./maybe");
const unit_1 = require("./unit");
const utils_1 = require("./utils");
// So that it doesn't appear unused but can be exported.
utils_1._Brand; // tslint:disable-line:no-unused-expression
/**
  Discriminant for `Ok` and `Err` variants of `Result` type.

  You can use the discriminant via the `variant` property of `Result` instances
  if you need to match explicitly on it.
 */
var Variant;
(function (Variant) {
    Variant["Ok"] = "Ok";
    Variant["Err"] = "Err";
})(Variant = exports.Variant || (exports.Variant = {}));
/**
  An `Ok` instance is the *successful* variant instance of the
  [`Result`](../modules/_result_.html#result) type, representing a successful
  outcome from an operation which may fail. For a full discussion, see [the
  module docs](../modules/_result_.html).

  @typeparam T The type wrapped in this `Ok` variant of `Result`.
  @typeparam E The type which would be wrapped in an `Err` variant of `Result`.
 */
class Ok {
    /**
      Create an instance of `Result.Ok` with `new`.
  
      Note: While you *may* create the `Result` type via normal
      JavaScript class construction, it is not recommended for the functional
      style for which the library is intended. Instead, use [`Result.ok`].
  
      [`Result.ok`]: ../modules/_result_.html#ok
  
      ```ts
      // Avoid:
      const aString = new Result.Ok('characters');
  
      // Prefer:
      const aString = Result.ok('characters);
      ```
  
      Note that you may explicitly pass `Unit` to the `Ok` constructor to create
      a `Result<Unit, E>`. However, you may *not* call the `Ok` constructor with
      `null` or `undefined` to get that result (the type system won't allow you to
      construct it that way). Instead, for convenience, you can simply call
      `Result.ok()`, which will construct the type correctly.
  
      @param value
      The value to wrap in a `Result.Ok`.
  
      Note: `null` and `undefined` are allowed by the type signature so that the
      constructor may `throw` on those rather than constructing a type like
      `Result<undefined>`.
  
      @throws If you pass `null`.
     */
    constructor(value) {
        /** `Ok` is always [`Variant.Ok`](../enums/_result_.variant#ok). */
        this.variant = Variant.Ok;
        if (utils_1.isVoid(value)) {
            throw new Error('Tried to construct `Ok` with `null` or `undefined`. Maybe you want `Maybe.Nothing`?');
        }
        this.value = value;
    }
    /**
      Unwrap the contained value. A convenience method for functional idioms.
  
      A common scenario where you might want to use this is in a pipeline of
      functions:
  
      ```ts
      import Result, { Ok } from 'true-myth/result';
  
      function getLengths(results: Array<Result<string, string>>): Array<number> {
        return results
          .filter(Result.isOk)
          .map(Ok.unwrap)
          .map(s => s.length);
      }
      ```
     */
    static unwrap(theOk) {
        return theOk.value;
    }
    /** Method variant for [`Result.isOk`](../modules/_result_.html#isok) */
    isOk() {
        return true;
    }
    /** Method variant for [`Result.isErr`](../modules/_result_.html#iserr) */
    isErr() {
        return false;
    }
    /** Method variant for [`Result.map`](../modules/_result_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Result.mapOr`](../modules/_result_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Result.mapOrElse`](../modules/_result_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Result.match`](../modules/_result_.html#match) */
    match(matcher) {
        return match(matcher, this);
    }
    /** Method variant for [`Result.mapErr`](../modules/_result_.html#maperr) */
    mapErr(mapErrFn) {
        return mapErr(mapErrFn, this);
    }
    /** Method variant for [`Result.or`](../modules/_result_.html#or) */
    or(orResult) {
        return or(orResult, this);
    }
    /** Method variant for [`Result.orElse`](../modules/_result_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Result.and`](../modules/_result_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Result.andThen`](../modules/_result_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Result.chain`](../modules/_result_.html#chain) */
    chain(chainFn) {
        return exports.chain(chainFn, this);
    }
    /** Method variant for [`Result.flatMap`](../modules/_result_.html#flatmap) */
    flatMap(flatMapFn) {
        return exports.flatMap(flatMapFn, this);
    }
    /** Method variant for [`Result.unwrap`](../modules/_result_.html#unwrap) */
    unsafelyUnwrap() {
        return this.value;
    }
    /** Method variant for [`Result.unwrapErr`](../modules/_result_.html#unwraperr) */
    unsafelyUnwrapErr() {
        throw new Error('Tried to `unsafelyUnwrapErr` an `Ok`');
    }
    /** Method variant for [`Result.unwrapOr`](../modules/_result_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Result.unwrapOrElse`](../modules/_result_.html#unwrapOrElse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Result.toMaybe`](../modules/_result_.html#tomaybe) */
    toMaybe() {
        return toMaybe(this);
    }
    /** Method variant for [`Result.toString`](../modules/_result_.html#tostring) */
    toString() {
        return exports.toString(this);
    }
    /** Method variant for [`Result.equals`](../modules/_result_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Result.ap`](../modules/_result_.html#ap) */
    ap(r) {
        return ap(this, r);
    }
}
exports.Ok = Ok;
/**
  An `Err` instance is the *failure* variant instance of the
  [`Result`](../modules/_result_.html#result) type, representing a failure
  outcome from an operation which may fail. For a full discussion, see [the
  module docs](../modules/_result_.html).

  @typeparam T The type which would be wrapped in an `Ok` variant of `Result`.
  @typeparam E The type wrapped in this `Err` variant of `Result`.
  */
class Err {
    /**
      Create an instance of `Result.Err` with `new`.
  
      Note: While you *may* create the `Result` type via normal
      JavaScript class construction, it is not recommended for the functional
      style for which the library is intended. Instead, use [`Result.err`].
  
      [`Result.err`]: ../modules/_result_.html#err
  
      ```ts
      // Avoid:
      const anErr = new Result.Err('alas, failure');
  
      // Prefer:
      const anErr = Result.err('alas, failure');
      ```
  
      Note that you may explicitly pass `Unit` to the `Err` constructor to create
      a `Result<T, Unit>`. However, you may *not* call the `Err` constructor with
      `null` or `undefined` to get that result (the type system won't allow you to
      construct it that way). Instead, for convenience, you can simply call
      `Result.err()`, which will construct the type correctly.
  
      @param error
      The value to wrap in a `Result.Err`.
  
      `Note: null` and `undefined` are allowed by the type signature so that the
      constructor may `throw` on those rather than constructing a type like
      `Result<number, undefined>`.
  
      @throws If you pass `null` or `undefined`.
     */
    constructor(error) {
        /** `Err` is always [`Variant.Err`](../enums/_result_.variant#err). */
        this.variant = Variant.Err;
        if (utils_1.isVoid(error)) {
            throw new Error('Tried to construct `Err` with `null` or `undefined`. Maybe you want `Maybe.Nothing`?');
        }
        this.error = error;
    }
    /**
      Unwrap the contained error . A convenience method for functional idioms.
  
      A common scenario where you might want to use this is in a pipeline of
      functions:
  
      ```ts
      import Result, { Ok } from 'true-myth/result';
  
      function getMessages(results: Array<Result<string, Error>>): Array<number> {
        return maybeStrings
          .filter(Result.isErr)
          .map(Err.unwrapErr)
          .map(e => e.message);
      }
      ```
     */
    static unwrapErr(theErr) {
        return theErr.error;
    }
    /** Method variant for [`Result.isOk`](../modules/_result_.html#isok) */
    isOk() {
        return false;
    }
    /** Method variant for [`Result.isErr`](../modules/_result_.html#iserr) */
    isErr() {
        return true;
    }
    /** Method variant for [`Result.map`](../modules/_result_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Result.mapOr`](../modules/_result_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Result.mapOrElse`](../modules/_result_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Result.match`](../modules/_result_.html#match) */
    match(matchObj) {
        return match(matchObj, this);
    }
    /** Method variant for [`Result.mapErr`](../modules/_result_.html#maperr) */
    mapErr(mapErrFn) {
        return mapErr(mapErrFn, this);
    }
    /** Method variant for [`Result.or`](../modules/_result_.html#or) */
    or(orResult) {
        return or(orResult, this);
    }
    /** Method variant for [`Result.orElse`](../modules/_result_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Result.and`](../modules/_result_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Result.andThen`](../modules/_result_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Result.chain`](../modules/_result_.html#chain) */
    chain(chainFn) {
        return this.andThen(chainFn);
    }
    /** Method variant for [`Result.flatMap`](../modules/_result_.html#flatmap) */
    flatMap(flatMapFn) {
        return this.andThen(flatMapFn);
    }
    /** Method variant for [`Result.unsafelyUnwrap`](../modules/_result_.html#unsafelyunwrap) */
    unsafelyUnwrap() {
        throw new Error('Tried to `unsafelyUnwrap an Err`');
    }
    /** Method variant for [`Result.unsafelyUnwrapErr`](../modules/_result_.html#unsafelyunwraperr) */
    unsafelyUnwrapErr() {
        return this.error;
    }
    /** Method variant for [`Result.unwrapOr`](../modules/_result_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Result.unwrapOrElse`](../modules/_result_.html#unwraporelse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Result.toMaybe`](../modules/_result_.html#tomaybe) */
    toMaybe() {
        return toMaybe(this);
    }
    /** Method variant for [`Result.toString`](../modules/_result_.html#tostring) */
    toString() {
        return exports.toString(this);
    }
    /** Method variant for [`Result.equals`](../modules/_result_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Result.ap`](../modules/_result_.html#ap) */
    ap(r) {
        return ap(this, r);
    }
}
exports.Err = Err;
/**
  Is this `Result` an `Ok` instance?

  In TypeScript, narrows the type from `Result<T, E>` to `Ok<T, E>`.
 */
function isOk(result) {
    return result.variant === Variant.Ok;
}
exports.isOk = isOk;
/**
  Is this `Result` an `Err` instance?

  In TypeScript, narrows the type from `Result<T, E>` to `Err<T, E>`.
 */
function isErr(result) {
    return result.variant === Variant.Err;
}
exports.isErr = isErr;
function ok(value) {
    return value === undefined ? new Ok(unit_1.default) : new Ok(value);
}
exports.ok = ok;
/** `Result.of` is an alias for `Result.ok`. */
exports.of = ok;
function err(error) {
    return utils_1.isVoid(error) ? new Err(unit_1.default) : new Err(error);
}
exports.err = err;
function tryOr(error, callback) {
    const op = (cb) => {
        try {
            return exports.Result.ok(cb());
        }
        catch (_a) {
            return exports.Result.err(error);
        }
    };
    return utils_1.curry1(op, callback);
}
exports.tryOr = tryOr;
function tryOrElse(onError, callback) {
    const op = (cb) => {
        try {
            return exports.Result.ok(cb());
        }
        catch (e) {
            return exports.Result.err(onError(e));
        }
    };
    return utils_1.curry1(op, callback);
}
exports.tryOrElse = tryOrElse;
function map(mapFn, result) {
    const op = (r) => (isOk(r) ? ok(mapFn(r.value)) : r);
    return utils_1.curry1(op, result);
}
exports.map = map;
function mapOr(orU, mapFn, result) {
    function fullOp(fn, r) {
        return isOk(r) ? fn(r.value) : orU;
    }
    function partialOp(fn, curriedResult) {
        return curriedResult !== undefined
            ? fullOp(fn, curriedResult)
            : (extraCurriedResult) => fullOp(fn, extraCurriedResult);
    }
    return mapFn === undefined
        ? partialOp
        : result === undefined
            ? partialOp(mapFn)
            : partialOp(mapFn, result);
}
exports.mapOr = mapOr;
function mapOrElse(orElseFn, mapFn, result) {
    function fullOp(fn, r) {
        return isOk(r) ? fn(r.value) : orElseFn(r.error);
    }
    function partialOp(fn, curriedResult) {
        return curriedResult !== undefined
            ? fullOp(fn, curriedResult)
            : (extraCurriedResult) => fullOp(fn, extraCurriedResult);
    }
    return mapFn === undefined
        ? partialOp
        : result === undefined
            ? partialOp(mapFn)
            : partialOp(mapFn, result);
}
exports.mapOrElse = mapOrElse;
function mapErr(mapErrFn, result) {
    const op = (r) => (isOk(r) ? r : err(mapErrFn(r.error)));
    return utils_1.curry1(op, result);
}
exports.mapErr = mapErr;
function and(andResult, result) {
    const op = (r) => (isOk(r) ? andResult : r);
    return utils_1.curry1(op, result);
}
exports.and = and;
function andThen(thenFn, result) {
    const op = (r) => (isOk(r) ? thenFn(r.value) : r);
    return utils_1.curry1(op, result);
}
exports.andThen = andThen;
/** Alias for [`andThen`](#andthen). */
exports.chain = andThen;
/** Alias for [`andThen`](#andthen). */
exports.flatMap = andThen;
function or(defaultResult, result) {
    const op = (r) => (isOk(r) ? r : defaultResult);
    return utils_1.curry1(op, result);
}
exports.or = or;
function orElse(elseFn, result) {
    const op = (r) => (isOk(r) ? r : elseFn(r.unsafelyUnwrapErr()));
    return utils_1.curry1(op, result);
}
exports.orElse = orElse;
/**
  Get the value out of the `Result`.

  Returns the content of an `Ok`, but **throws if the `Result` is `Err`.**
  Prefer to use [`unwrapOr`](#unwrapor) or [`unwrapOrElse`](#unwraporelse).

  @throws If the `Result` instance is `Nothing`.
 */
function unsafelyUnwrap(result) {
    return result.unsafelyUnwrap();
}
exports.unsafelyUnwrap = unsafelyUnwrap;
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
exports.unsafelyGet = unsafelyUnwrap;
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
exports.unsafeGet = unsafelyUnwrap;
/**
  Get the error value out of the [`Result`](#result).

  Returns the content of an `Err`, but **throws if the `Result` is `Ok`**.
  Prefer to use [`unwrapOrElse`](#unwraporelse).

  @param result
  @throws Error If the `Result` instance is `Nothing`.
 */
function unsafelyUnwrapErr(result) {
    return result.unsafelyUnwrapErr();
}
exports.unsafelyUnwrapErr = unsafelyUnwrapErr;
/** Alias for [`unsafelyUnwrapErr`](#unsafelyunwraperr) */
exports.unsafelyGetErr = unsafelyUnwrapErr;
function unwrapOr(defaultValue, result) {
    const op = (r) => (isOk(r) ? r.value : defaultValue);
    return utils_1.curry1(op, result);
}
exports.unwrapOr = unwrapOr;
/** Alias for [`unwrapOr`](#unwrapor) */
exports.getOr = unwrapOr;
function unwrapOrElse(orElseFn, result) {
    const op = (r) => (isOk(r) ? r.value : orElseFn(r.error));
    return utils_1.curry1(op, result);
}
exports.unwrapOrElse = unwrapOrElse;
/** Alias for [`unwrapOrElse`](#unwraporelse) */
exports.getOrElse = unwrapOrElse;
/**
  Convert a [`Result`](#result) to a [`Maybe`](../modules/_maybe_.html#maybe).

  The converted type will be [`Just`] if the `Result` is [`Ok`] or [`Nothing`]
  if the `Result` is [`Err`]; the wrapped error value will be discarded.

  [`Just`]: ../classes/_maybe_.just.html
  [`Nothing`]: ../classes/_maybe_.nothing.html
  [`Ok`]: ../classes/_result_.ok.html
  [`Err`]: ../classes/_result_.err.html

  @param result The `Result` to convert to a `Maybe`
  @returns      `Just` the value in `result` if it is `Ok`; otherwise `Nothing`
 */
function toMaybe(result) {
    return isOk(result) ? maybe_1.just(result.value) : maybe_1.nothing();
}
exports.toMaybe = toMaybe;
function fromMaybe(errValue, maybe) {
    const op = (m) => (maybe_1.isJust(m) ? ok(maybe_1.default.unsafelyUnwrap(m)) : err(errValue));
    return utils_1.curry1(op, maybe);
}
exports.fromMaybe = fromMaybe;
/**
  Create a `String` representation of a `result` instance.

  An `Ok` instance will be printed as `Ok(<representation of the value>)`, and
  an `Err` instance will be printed as `Err(<representation of the error>)`,
  where the representation of the value or error is simply the value or error's
  own `toString` representation. For example:

                call                |         output
  --------------------------------- | ----------------------
  `toString(ok(42))`                | `Ok(42)`
  `toString(ok([1, 2, 3]))`         | `Ok(1,2,3)`
  `toString(ok({ an: 'object' }))`  | `Ok([object Object])`n
  `toString(err(42))`               | `Err(42)`
  `toString(err([1, 2, 3]))`        | `Err(1,2,3)`
  `toString(err({ an: 'object' }))` | `Err([object Object])`

  @typeparam T The type of the wrapped value; its own `.toString` will be used
               to print the interior contents of the `Just` variant.
  @param maybe The value to convert to a string.
  @returns     The string representation of the `Maybe`.
 */
exports.toString = (result) => {
    const body = (isOk(result) ? result.value : result.error).toString();
    return `${result.variant.toString()}(${body})`;
};
function match(matcher, result) {
    const op = (r) => mapOrElse(matcher.Err, matcher.Ok, r);
    return utils_1.curry1(op, result);
}
exports.match = match;
/** Alias for [`match`](#match) */
exports.cata = match;
function equals(resultB, resultA) {
    return resultA !== undefined
        ? resultA.match({
            Err: () => isErr(resultB),
            Ok: a => isOk(resultB) && resultB.unsafelyUnwrap() === a,
        })
        : (curriedResultA) => curriedResultA.match({
            Err: () => isErr(resultB),
            Ok: a => isOk(resultB) && resultB.unsafelyUnwrap() === a,
        });
}
exports.equals = equals;
function ap(resultFn, result) {
    const op = (r) => r.match({
        Ok: val => resultFn.map(fn => fn(val)),
        Err: e => exports.Result.err(e),
    });
    return utils_1.curry1(op, result);
}
exports.ap = ap;
/**
  Determine whether an item is an instance of `Just` or `Nothing`.

  @param item The item to check.
 */
function isInstance(item) {
    return item instanceof Ok || item instanceof Err;
}
exports.isInstance = isInstance;
exports.Result = {
    Variant,
    Ok,
    Err,
    isOk,
    isErr,
    ok,
    err,
    tryOr,
    tryOrElse,
    map,
    mapOr,
    mapOrElse,
    mapErr,
    and,
    andThen,
    chain: exports.chain,
    flatMap: exports.flatMap,
    or,
    orElse,
    unsafelyUnwrap,
    unsafelyGet: exports.unsafelyGet,
    unsafeGet: exports.unsafeGet,
    unsafelyUnwrapErr,
    unsafelyGetErr: exports.unsafelyGetErr,
    unwrapOr,
    getOr: exports.getOr,
    unwrapOrElse,
    getOrElse: exports.getOrElse,
    toMaybe,
    fromMaybe,
    toString: exports.toString,
    match,
    cata: exports.cata,
    equals,
    ap,
    isInstance,
};
exports.default = exports.Result;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzdWx0LmpzIiwic291cmNlUm9vdCI6Ii4vIiwic291cmNlcyI6WyJyZXN1bHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLGdDQUFnQzs7QUFFaEMseURBQXlEO0FBQ3pELG1DQUF1RDtBQUN2RCxpQ0FBMEI7QUFDMUIsbUNBQWlEO0FBRWpELHdEQUF3RDtBQUN4RCxjQUFNLENBQUMsQ0FBQywyQ0FBMkM7QUFFbkQ7Ozs7O0dBS0c7QUFDSCxJQUFZLE9BR1g7QUFIRCxXQUFZLE9BQU87SUFDakIsb0JBQVMsQ0FBQTtJQUNULHNCQUFXLENBQUE7QUFDYixDQUFDLEVBSFcsT0FBTyxHQUFQLGVBQU8sS0FBUCxlQUFPLFFBR2xCO0FBdUVEOzs7Ozs7OztHQVFHO0FBQ0gsTUFBYSxFQUFFO0lBNEJiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BK0JHO0lBQ0gsWUFBWSxLQUFnQjtRQXRDNUIsbUVBQW1FO1FBQzFELFlBQU8sR0FBZSxPQUFPLENBQUMsRUFBRSxDQUFDO1FBc0N4QyxJQUFJLGNBQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUNiLHFGQUFxRixDQUN0RixDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBbkVEOzs7Ozs7Ozs7Ozs7Ozs7O09BZ0JHO0lBQ0gsTUFBTSxDQUFDLE1BQU0sQ0FBSSxLQUFpQjtRQUNoQyxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUM7SUFDckIsQ0FBQztJQWtERCx3RUFBd0U7SUFDeEUsSUFBSTtRQUNGLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELDBFQUEwRTtJQUMxRSxLQUFLO1FBQ0gsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsc0VBQXNFO0lBQ3RFLEdBQUcsQ0FBd0IsS0FBa0I7UUFDM0MsT0FBTyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUM7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QUk7SUFDSixLQUFLO0lBQ0wsRUFBRTtJQUNGLEdBQUc7SUFDSCxLQUFLO0lBQ0wsU0FBUztJQUNULEdBQUc7SUFDSCxLQUFLO0lBQ0wsU0FBUztJQUNULE1BQU07SUFDTixHQUFHO0lBQ0gsT0FBTztJQUNQLEtBQUssRUFBTCxhQUFLO0lBQ0wsT0FBTyxFQUFQLGVBQU87SUFDUCxFQUFFO0lBQ0YsTUFBTTtJQUNOLGNBQWM7SUFDZCxXQUFXLEVBQVgsbUJBQVc7SUFDWCxTQUFTLEVBQVQsaUJBQVM7SUFDVCxpQkFBaUI7SUFDakIsY0FBYyxFQUFkLHNCQUFjO0lBQ2QsUUFBUTtJQUNSLEtBQUssRUFBTCxhQUFLO0lBQ0wsWUFBWTtJQUNaLFNBQVMsRUFBVCxpQkFBUztJQUNULE9BQU87SUFDUCxTQUFTO0lBQ1QsUUFBUSxFQUFSLGdCQUFRO0lBQ1IsS0FBSztJQUNMLElBQUksRUFBSixZQUFJO0lBQ0osTUFBTTtJQUNOLEVBQUU7SUFDRixVQUFVO0NBQ1gsQ0FBQztBQUVGLGtCQUFlLGNBQU0sQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBbW2luY2x1ZGU6ZG9jL3Jlc3VsdC5tZF1dICovXG5cbi8qKiAoa2VlcCB0eXBlZG9jIGZyb20gZ2V0dGluZyBjb25mdXNlZCBieSB0aGUgaW1wb3J0KSAqL1xuaW1wb3J0IE1heWJlLCB7IGlzSnVzdCwganVzdCwgbm90aGluZyB9IGZyb20gJy4vbWF5YmUnO1xuaW1wb3J0IFVuaXQgZnJvbSAnLi91bml0JztcbmltcG9ydCB7IF9CcmFuZCwgY3VycnkxLCBpc1ZvaWQgfSBmcm9tICcuL3V0aWxzJztcblxuLy8gU28gdGhhdCBpdCBkb2Vzbid0IGFwcGVhciB1bnVzZWQgYnV0IGNhbiBiZSBleHBvcnRlZC5cbl9CcmFuZDsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvblxuXG4vKipcbiAgRGlzY3JpbWluYW50IGZvciBgT2tgIGFuZCBgRXJyYCB2YXJpYW50cyBvZiBgUmVzdWx0YCB0eXBlLlxuXG4gIFlvdSBjYW4gdXNlIHRoZSBkaXNjcmltaW5hbnQgdmlhIHRoZSBgdmFyaWFudGAgcHJvcGVydHkgb2YgYFJlc3VsdGAgaW5zdGFuY2VzXG4gIGlmIHlvdSBuZWVkIHRvIG1hdGNoIGV4cGxpY2l0bHkgb24gaXQuXG4gKi9cbmV4cG9ydCBlbnVtIFZhcmlhbnQge1xuICBPayA9ICdPaycsXG4gIEVyciA9ICdFcnInLFxufVxuXG4vKiogU2ltcGx5IGRlZmluZXMgdGhlIGNvbW1vbiBzaGFwZSBmb3IgYE9rYCBhbmQgYEVycmAuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3VsdFNoYXBlPFQsIEU+IHtcbiAgLyoqIERpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIGBPa2AgYW5kIGBFcnJgIHZhcmlhbnRzLiAqL1xuICByZWFkb25seSB2YXJpYW50OiBWYXJpYW50O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuaXNPa2BdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNpc29rKSAqL1xuICBpc09rKHRoaXM6IFJlc3VsdDxULCBFPik6IHRoaXMgaXMgT2s8VCwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5pc0VycmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNpc2VycikgKi9cbiAgaXNFcnIodGhpczogUmVzdWx0PFQsIEU+KTogdGhpcyBpcyBFcnI8VCwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjbWFwKSAqL1xuICBtYXA8VT4odGhpczogUmVzdWx0PFQsIEU+LCBtYXBGbjogKHQ6IFQpID0+IFUpOiBSZXN1bHQ8VSwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBPcmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNtYXBvcikgKi9cbiAgbWFwT3I8VT4odGhpczogUmVzdWx0PFQsIEU+LCBvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFU7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBPckVsc2VgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjbWFwb3JlbHNlKSAqL1xuICBtYXBPckVsc2U8VT4odGhpczogUmVzdWx0PFQsIEU+LCBvckVsc2VGbjogKGVycjogRSkgPT4gVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogVTtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0Lm1hdGNoYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI21hdGNoKSAqL1xuICBtYXRjaDxVPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG1hdGNoZXI6IE1hdGNoZXI8VCwgRSwgVT4pOiBVO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQubWFwRXJyYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI21hcGVycikgKi9cbiAgbWFwRXJyPEY+KHRoaXM6IFJlc3VsdDxULCBFPiwgbWFwRXJyRm46IChlOiBFKSA9PiBGKTogUmVzdWx0PFQsIEY+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQub3JgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjb3IpICovXG4gIG9yPEY+KHRoaXM6IFJlc3VsdDxULCBFPiwgb3JSZXN1bHQ6IFJlc3VsdDxULCBGPik6IFJlc3VsdDxULCBGPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0Lm9yRWxzZWBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNvcmVsc2UpICovXG4gIG9yRWxzZTxGPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG9yRWxzZUZuOiAoZXJyOiBFKSA9PiBSZXN1bHQ8VCwgRj4pOiBSZXN1bHQ8VCwgRj47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5hbmRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjYW5kKSAqL1xuICBhbmQ8VT4odGhpczogUmVzdWx0PFQsIEU+LCBtQW5kOiBSZXN1bHQ8VSwgRT4pOiBSZXN1bHQ8VSwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5hbmRUaGVuYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2FuZHRoZW4pICovXG4gIGFuZFRoZW48VT4odGhpczogUmVzdWx0PFQsIEU+LCBhbmRUaGVuRm46ICh0OiBUKSA9PiBSZXN1bHQ8VSwgRT4pOiBSZXN1bHQ8VSwgRT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5jaGFpbmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNjaGFpbikgKi9cbiAgY2hhaW48VT4odGhpczogUmVzdWx0PFQsIEU+LCBjaGFpbkZuOiAodDogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuZmxhdE1hcGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNmbGF0bWFwKSAqL1xuICBmbGF0TWFwPFU+KHRoaXM6IFJlc3VsdDxULCBFPiwgY2hhaW5GbjogKHQ6IFQpID0+IFJlc3VsdDxVLCBFPik6IFJlc3VsdDxVLCBFPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnVud3JhcGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN1bndyYXApICovXG4gIHVuc2FmZWx5VW53cmFwKCk6IFQgfCBuZXZlcjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnVud3JhcEVycmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN1bndyYXBlcnIpICovXG4gIHVuc2FmZWx5VW53cmFwRXJyKCk6IEUgfCBuZXZlcjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnVud3JhcE9yYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Vud3JhcG9yKSAqL1xuICB1bndyYXBPcih0aGlzOiBSZXN1bHQ8VCwgRT4sIGRlZmF1bHRWYWx1ZTogVCk6IFQ7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC51bndyYXBPckVsc2VgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjdW53cmFwT3JFbHNlKSAqL1xuICB1bndyYXBPckVsc2UodGhpczogUmVzdWx0PFQsIEU+LCBlbHNlRm46IChlcnJvcjogRSkgPT4gVCk6IFQ7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC50b01heWJlYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3RvbWF5YmUpICovXG4gIHRvTWF5YmUodGhpczogUmVzdWx0PFQsIEU+KTogTWF5YmU8VD47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC50b1N0cmluZ2BdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN0b3N0cmluZykgKi9cbiAgdG9TdHJpbmcodGhpczogUmVzdWx0PFQsIEU+KTogc3RyaW5nO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuZXF1YWxzYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2VxdWFscykgKi9cbiAgZXF1YWxzKHRoaXM6IFJlc3VsdDxULCBFPiwgY29tcGFyaXNvbjogUmVzdWx0PFQsIEU+KTogYm9vbGVhbjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmFwYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2FwKSAqL1xuICBhcDxBLCBCPih0aGlzOiBSZXN1bHQ8KGE6IEEpID0+IEIsIEU+LCByOiBSZXN1bHQ8QSwgRT4pOiBSZXN1bHQ8QiwgRT47XG59XG5cbi8qKlxuICBBbiBgT2tgIGluc3RhbmNlIGlzIHRoZSAqc3VjY2Vzc2Z1bCogdmFyaWFudCBpbnN0YW5jZSBvZiB0aGVcbiAgW2BSZXN1bHRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjcmVzdWx0KSB0eXBlLCByZXByZXNlbnRpbmcgYSBzdWNjZXNzZnVsXG4gIG91dGNvbWUgZnJvbSBhbiBvcGVyYXRpb24gd2hpY2ggbWF5IGZhaWwuIEZvciBhIGZ1bGwgZGlzY3Vzc2lvbiwgc2VlIFt0aGVcbiAgbW9kdWxlIGRvY3NdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCkuXG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIHdyYXBwZWQgaW4gdGhpcyBgT2tgIHZhcmlhbnQgb2YgYFJlc3VsdGAuXG4gIEB0eXBlcGFyYW0gRSBUaGUgdHlwZSB3aGljaCB3b3VsZCBiZSB3cmFwcGVkIGluIGFuIGBFcnJgIHZhcmlhbnQgb2YgYFJlc3VsdGAuXG4gKi9cbmV4cG9ydCBjbGFzcyBPazxULCBFPiBpbXBsZW1lbnRzIFJlc3VsdFNoYXBlPFQsIEU+IHtcbiAgLyoqXG4gICAgVW53cmFwIHRoZSBjb250YWluZWQgdmFsdWUuIEEgY29udmVuaWVuY2UgbWV0aG9kIGZvciBmdW5jdGlvbmFsIGlkaW9tcy5cblxuICAgIEEgY29tbW9uIHNjZW5hcmlvIHdoZXJlIHlvdSBtaWdodCB3YW50IHRvIHVzZSB0aGlzIGlzIGluIGEgcGlwZWxpbmUgb2ZcbiAgICBmdW5jdGlvbnM6XG5cbiAgICBgYGB0c1xuICAgIGltcG9ydCBSZXN1bHQsIHsgT2sgfSBmcm9tICd0cnVlLW15dGgvcmVzdWx0JztcblxuICAgIGZ1bmN0aW9uIGdldExlbmd0aHMocmVzdWx0czogQXJyYXk8UmVzdWx0PHN0cmluZywgc3RyaW5nPj4pOiBBcnJheTxudW1iZXI+IHtcbiAgICAgIHJldHVybiByZXN1bHRzXG4gICAgICAgIC5maWx0ZXIoUmVzdWx0LmlzT2spXG4gICAgICAgIC5tYXAoT2sudW53cmFwKVxuICAgICAgICAubWFwKHMgPT4gcy5sZW5ndGgpO1xuICAgIH1cbiAgICBgYGBcbiAgICovXG4gIHN0YXRpYyB1bndyYXA8Tz4odGhlT2s6IE9rPE8sIGFueT4pOiBPIHtcbiAgICByZXR1cm4gdGhlT2sudmFsdWU7XG4gIH1cblxuICAvKiogYE9rYCBpcyBhbHdheXMgW2BWYXJpYW50Lk9rYF0oLi4vZW51bXMvX3Jlc3VsdF8udmFyaWFudCNvaykuICovXG4gIHJlYWRvbmx5IHZhcmlhbnQ6IFZhcmlhbnQuT2sgPSBWYXJpYW50Lk9rO1xuXG4gIC8qKiBUaGUgd3JhcHBlZCB2YWx1ZS4gKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFQ7XG5cbiAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBSZXN1bHQuT2tgIHdpdGggYG5ld2AuXG5cbiAgICBOb3RlOiBXaGlsZSB5b3UgKm1heSogY3JlYXRlIHRoZSBgUmVzdWx0YCB0eXBlIHZpYSBub3JtYWxcbiAgICBKYXZhU2NyaXB0IGNsYXNzIGNvbnN0cnVjdGlvbiwgaXQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB0aGUgZnVuY3Rpb25hbFxuICAgIHN0eWxlIGZvciB3aGljaCB0aGUgbGlicmFyeSBpcyBpbnRlbmRlZC4gSW5zdGVhZCwgdXNlIFtgUmVzdWx0Lm9rYF0uXG5cbiAgICBbYFJlc3VsdC5va2BdOiAuLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjb2tcblxuICAgIGBgYHRzXG4gICAgLy8gQXZvaWQ6XG4gICAgY29uc3QgYVN0cmluZyA9IG5ldyBSZXN1bHQuT2soJ2NoYXJhY3RlcnMnKTtcblxuICAgIC8vIFByZWZlcjpcbiAgICBjb25zdCBhU3RyaW5nID0gUmVzdWx0Lm9rKCdjaGFyYWN0ZXJzKTtcbiAgICBgYGBcblxuICAgIE5vdGUgdGhhdCB5b3UgbWF5IGV4cGxpY2l0bHkgcGFzcyBgVW5pdGAgdG8gdGhlIGBPa2AgY29uc3RydWN0b3IgdG8gY3JlYXRlXG4gICAgYSBgUmVzdWx0PFVuaXQsIEU+YC4gSG93ZXZlciwgeW91IG1heSAqbm90KiBjYWxsIHRoZSBgT2tgIGNvbnN0cnVjdG9yIHdpdGhcbiAgICBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdG8gZ2V0IHRoYXQgcmVzdWx0ICh0aGUgdHlwZSBzeXN0ZW0gd29uJ3QgYWxsb3cgeW91IHRvXG4gICAgY29uc3RydWN0IGl0IHRoYXQgd2F5KS4gSW5zdGVhZCwgZm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIHNpbXBseSBjYWxsXG4gICAgYFJlc3VsdC5vaygpYCwgd2hpY2ggd2lsbCBjb25zdHJ1Y3QgdGhlIHR5cGUgY29ycmVjdGx5LlxuXG4gICAgQHBhcmFtIHZhbHVlXG4gICAgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgUmVzdWx0Lk9rYC5cblxuICAgIE5vdGU6IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGFsbG93ZWQgYnkgdGhlIHR5cGUgc2lnbmF0dXJlIHNvIHRoYXQgdGhlXG4gICAgY29uc3RydWN0b3IgbWF5IGB0aHJvd2Agb24gdGhvc2UgcmF0aGVyIHRoYW4gY29uc3RydWN0aW5nIGEgdHlwZSBsaWtlXG4gICAgYFJlc3VsdDx1bmRlZmluZWQ+YC5cblxuICAgIEB0aHJvd3MgSWYgeW91IHBhc3MgYG51bGxgLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWU/OiBUIHwgbnVsbCkge1xuICAgIGlmIChpc1ZvaWQodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUcmllZCB0byBjb25zdHJ1Y3QgYE9rYCB3aXRoIGBudWxsYCBvciBgdW5kZWZpbmVkYC4gTWF5YmUgeW91IHdhbnQgYE1heWJlLk5vdGhpbmdgPydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5pc09rYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2lzb2spICovXG4gIGlzT2sodGhpczogUmVzdWx0PFQsIEU+KTogdGhpcyBpcyBPazxULCBFPiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmlzRXJyYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2lzZXJyKSAqL1xuICBpc0Vycih0aGlzOiBSZXN1bHQ8VCwgRT4pOiB0aGlzIGlzIEVycjxULCBFPiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjbWFwKSAqL1xuICBtYXA8VT4odGhpczogUmVzdWx0PFQsIEU+LCBtYXBGbjogKHQ6IFQpID0+IFUpOiBSZXN1bHQ8VSwgRT4ge1xuICAgIHJldHVybiBtYXAobWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5tYXBPcmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNtYXBvcikgKi9cbiAgbWFwT3I8VT4odGhpczogUmVzdWx0PFQsIEU+LCBvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFUge1xuICAgIHJldHVybiBtYXBPcihvclUsIG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQubWFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI21hcG9yZWxzZSkgKi9cbiAgbWFwT3JFbHNlPFU+KHRoaXM6IFJlc3VsdDxULCBFPiwgb3JFbHNlRm46IChlcnI6IEUpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFUge1xuICAgIHJldHVybiBtYXBPckVsc2Uob3JFbHNlRm4sIG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQubWF0Y2hgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjbWF0Y2gpICovXG4gIG1hdGNoPFU+KHRoaXM6IFJlc3VsdDxULCBFPiwgbWF0Y2hlcjogTWF0Y2hlcjxULCBFLCBVPik6IFUge1xuICAgIHJldHVybiBtYXRjaChtYXRjaGVyLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQubWFwRXJyYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI21hcGVycikgKi9cbiAgbWFwRXJyPEY+KHRoaXM6IFJlc3VsdDxULCBFPiwgbWFwRXJyRm46IChlOiBFKSA9PiBGKTogUmVzdWx0PFQsIEY+IHtcbiAgICByZXR1cm4gbWFwRXJyKG1hcEVyckZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQub3JgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjb3IpICovXG4gIG9yPEY+KHRoaXM6IFJlc3VsdDxULCBFPiwgb3JSZXN1bHQ6IFJlc3VsdDxULCBGPik6IFJlc3VsdDxULCBGPiB7XG4gICAgcmV0dXJuIG9yKG9yUmVzdWx0LCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQub3JFbHNlYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI29yZWxzZSkgKi9cbiAgb3JFbHNlPEY+KHRoaXM6IFJlc3VsdDxULCBFPiwgb3JFbHNlRm46IChlcnI6IEUpID0+IFJlc3VsdDxULCBGPik6IFJlc3VsdDxULCBGPiB7XG4gICAgcmV0dXJuIG9yRWxzZShvckVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmFuZGBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNhbmQpICovXG4gIGFuZDxVPih0aGlzOiBSZXN1bHQ8VCwgRT4sIG1BbmQ6IFJlc3VsdDxVLCBFPik6IFJlc3VsdDxVLCBFPiB7XG4gICAgcmV0dXJuIGFuZChtQW5kLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuYW5kVGhlbmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNhbmR0aGVuKSAqL1xuICBhbmRUaGVuPFU+KHRoaXM6IFJlc3VsdDxULCBFPiwgYW5kVGhlbkZuOiAodDogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+IHtcbiAgICByZXR1cm4gYW5kVGhlbihhbmRUaGVuRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC5jaGFpbmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCNjaGFpbikgKi9cbiAgY2hhaW48VT4odGhpczogUmVzdWx0PFQsIEU+LCBjaGFpbkZuOiAodDogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+IHtcbiAgICByZXR1cm4gY2hhaW4oY2hhaW5GbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LmZsYXRNYXBgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjZmxhdG1hcCkgKi9cbiAgZmxhdE1hcDxVPih0aGlzOiBSZXN1bHQ8VCwgRT4sIGZsYXRNYXBGbjogKHQ6IFQpID0+IFJlc3VsdDxVLCBFPik6IFJlc3VsdDxVLCBFPiB7XG4gICAgcmV0dXJuIGZsYXRNYXAoZmxhdE1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQudW53cmFwYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Vud3JhcCkgKi9cbiAgdW5zYWZlbHlVbndyYXAoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnVud3JhcEVycmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN1bndyYXBlcnIpICovXG4gIHVuc2FmZWx5VW53cmFwRXJyKCk6IG5ldmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGB1bnNhZmVseVVud3JhcEVycmAgYW4gYE9rYCcpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYFJlc3VsdC51bndyYXBPcmBdKC4uL21vZHVsZXMvX3Jlc3VsdF8uaHRtbCN1bndyYXBvcikgKi9cbiAgdW53cmFwT3IodGhpczogUmVzdWx0PFQsIEU+LCBkZWZhdWx0VmFsdWU6IFQpOiBUIHtcbiAgICByZXR1cm4gdW53cmFwT3IoZGVmYXVsdFZhbHVlLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQudW53cmFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Vud3JhcE9yRWxzZSkgKi9cbiAgdW53cmFwT3JFbHNlKHRoaXM6IFJlc3VsdDxULCBFPiwgZWxzZUZuOiAoZXJyb3I6IEUpID0+IFQpOiBUIHtcbiAgICByZXR1cm4gdW53cmFwT3JFbHNlKGVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnRvTWF5YmVgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjdG9tYXliZSkgKi9cbiAgdG9NYXliZSh0aGlzOiBSZXN1bHQ8VCwgRT4pOiBNYXliZTxUPiB7XG4gICAgcmV0dXJuIHRvTWF5YmUodGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgUmVzdWx0LnRvU3RyaW5nYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Rvc3RyaW5nKSAqL1xuICB0b1N0cmluZyh0aGlzOiBSZXN1bHQ8VCwgRT4pOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuZXF1YWxzYF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI2VxdWFscykgKi9cbiAgZXF1YWxzKHRoaXM6IFJlc3VsdDxULCBFPiwgY29tcGFyaXNvbjogUmVzdWx0PFQsIEU+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVxdWFscyhjb21wYXJpc29uLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BSZXN1bHQuYXBgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjYXApICovXG4gIGFwPEEsIEI+KHRoaXM6IFJlc3VsdDwoYTogQSkgPT4gQiwgRT4sIHI6IFJlc3VsdDxBLCBFPik6IFJlc3VsdDxCLCBFPiB7XG4gICAgcmV0dXJuIGFwKHRoaXMsIHIpO1xuICB9XG59XG5cbi8qKlxuICBBbiBgRXJyYCBpbnN0YW5jZSBpcyB0aGUgKmZhaWx1cmUqIHZhcmlhbnQgaW5zdGFuY2Ugb2YgdGhlXG4gIFtgUmVzdWx0YF0oLi4vbW9kdWxlcy9fcmVzdWx0Xy5odG1sI3Jlc3VsdCkgdHlwZSwgcmVwcmVzZW50aW5nIGEgZmFpbHVyZVxuICBvdXRjb21lIGZyb20gYW4gb3BlcmF0aW9uIHdoaWNoIG1heSBmYWlsLiBGb3IgYSBmdWxsIGRpc2N1c3Npb24sIHNlZSBbdGhlXG4gIG1vZHVsZSBkb2NzXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwpLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSB3aGljaCB3b3VsZCBiZSB3cmFwcGVkIGluIGFuIGBPa2AgdmFyaWFudCBvZiBgUmVzdWx0YC5cbiAgQHR5cGVwYXJhbSBFIFRoZSB0eXBlIHdyYXBwZWQgaW4gdGhpcyBgRXJyYCB2YXJpYW50IG9mIGBSZXN1bHRgLlxuICAqL1xuZXhwb3J0IGNsYXNzIEVycjxULCBFPiBpbXBsZW1lbnRzIFJlc3VsdFNoYXBlPFQsIEU+IHtcbiAgLyoqXG4gICAgVW53cmFwIHRoZSBjb250YWluZWQgZXJyb3IgLiBBIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgZnVuY3Rpb25hbCBpZGlvbXMuXG5cbiAgICBBIGNvbW1vbiBzY2VuYXJpbyB3aGVyZSB5b3UgbWlnaHQgd2FudCB0byB1c2UgdGhpcyBpcyBpbiBhIHBpcGVsaW5lIG9mXG4gICAgZnVuY3Rpb25zOlxuXG4gICAgYGBgdHNcbiAgICBpbXBvcnQgUmVzdWx0LCB7IE9rIH0gZnJvbSAndHJ1ZS1teXRoL3Jlc3VsdCc7XG5cbiAgICBmdW5jdGlvbiBnZXRNZXNzYWdlcyhyZXN1bHRzOiBBcnJheTxSZXN1bHQ8c3RyaW5nLCBFcnJvcj4+KTogQXJyYXk8bnVtYmVyPiB7XG4gICAgICByZXR1cm4gbWF5YmVTdHJpbmdzXG4gICAgICAgIC5ma